<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>    <div class="description">
        <h1>Preposition: BEFORE</h1>
        
        <p class="web-editor-link-container">
            <a href="https://editor.p5js.org/npuckett/sketches/09_b4Rpy1" target="_blank" class="web-editor-link">
                Open this sketch in P5 Web Editor →
            </a>
        </p>
        
        <h3>Try It</h3>
        <p>Click "Start Timer" to begin the animation sequence. Watch as events happen before the main event at 3 seconds, demonstrating temporal relationships.</p>
    </div>

    <div class="container">
        <div class="canvas-container">
            <div id="canvas"></div>
        </div>
    </div>

    <div class="description">
        <h3>Concept</h3>
        <p><strong>BEFORE</strong> means occurring earlier in time than a reference point. In programming, this involves comparing timestamps, managing event sequences, and creating time-based conditions.</p>
        
        <h3>Translation Strategy</h3>
        <p>To create "before" relationships in time:</p>
        <ul>
            <li><strong>Time Tracking:</strong> Monitor elapsed time from a starting point</li>
            <li><strong>Event Sequencing:</strong> Schedule events to occur before a main event</li>
            <li><strong>Conditional Logic:</strong> Use time comparisons to trigger actions</li>
        </ul>
        
        <h3>Key P5.js Methods</h3>
        <div class="code-section">
            <strong>Time Management:</strong><br>
            • <a href="https://p5js.org/reference/p5/millis" target="_blank">millis()</a> - Get current time in milliseconds<br>
            • Time calculations: <code>elapsedTime = (millis() - startTime) / 1000</code><br>
            • <a href="https://p5js.org/reference/p5/frameCount" target="_blank">frameCount</a> - Track frames for timing<br><br>
            
            <strong>Conditional Logic:</strong><br>
            • Time comparisons: <code>if (currentTime < eventTime)</code><br>
            • Boolean flags for event states: <code>let eventHappened = false</code><br>
            • Multiple condition checks for sequences<br><br>
            
            <strong>Visual Elements:</strong><br>
            • <a href="https://p5js.org/reference/p5/fill" target="_blank">fill(r, g, b, alpha)</a> - Change colors based on time<br>
            • <a href="https://p5js.org/reference/p5/textAlign" target="_blank">textAlign()</a> - Position time displays<br>
            • Progress bars and timeline visualizations<br><br>
            
            <strong>Animation:</strong><br>
            • State-based animations depending on time<br>
            • Smooth transitions using time interpolation<br><br>
            
            <strong>User Interaction:</strong><br>
            • Button controls for starting/stopping timers<br>
            • Reset functionality to restart sequences
        </div>
        
        <h3>Code Structure</h3>
        <div class="code-section">
            <strong>Basic Pattern for "Before":</strong><br><br>
            
            1. <strong>Setup time variables:</strong> Track start time and target event time<br>
            <code>let startTime;</code><br>
            <code>let mainEventTime = 3; // seconds</code><br>
            <code>let timerRunning = false;</code><br><br>
            
            2. <strong>Calculate elapsed time:</strong> Monitor current time<br>
            <code>let elapsedTime = (millis() - startTime) / 1000;</code><br><br>
            
            3. <strong>Check temporal relationships:</strong> Compare times<br>
            <code>if (elapsedTime < mainEventTime) {</code><br>
            <code>&nbsp;&nbsp;// This happens BEFORE the main event</code><br>
            <code>&nbsp;&nbsp;triggerPreEvents();</code><br>
            <code>} else {</code><br>
            <code>&nbsp;&nbsp;// Main event or after</code><br>
            <code>&nbsp;&nbsp;triggerMainEvent();</code><br>
            <code>}</code>
        </div>
    </div>

    <script>
        let startTime;
        let timerRunning = false;
        let mainEventTime = 3; // seconds
        let events = [];
        let particles = [];
        
        function setup() {
            createCanvas(400, 300).parent('canvas');
            
            // Define events that happen before the main event
            events = [
                { time: 0.5, message: "Preparation begins", color: [100, 150, 255], triggered: false },
                { time: 1.5, message: "Setup phase", color: [150, 100, 255], triggered: false },
                { time: 2.5, message: "Final preparations", color: [255, 150, 100], triggered: false },
                { time: 3.0, message: "MAIN EVENT!", color: [255, 100, 100], triggered: false, isMain: true }
            ];
        }
        
        function draw() {
            background(240);
            
            let currentTime = 0;
            if (timerRunning && startTime) {
                currentTime = (millis() - startTime) / 1000;
            }
            
            // Draw timeline
            drawTimeline(currentTime);
            
            // Check and trigger events
            for (let event of events) {
                if (timerRunning && currentTime >= event.time && !event.triggered) {
                    event.triggered = true;
                    if (!event.isMain) {
                        // Add particles for events that happen BEFORE
                        addParticles(event.color);
                    }
                }
            }
            
            // Update and draw particles
            updateParticles();
            
            // Draw event status
            drawEventStatus(currentTime);
            
            // Draw control buttons
            drawControls();
            
            // Draw relationship text
            let relationship = "";
            if (!timerRunning) {
                relationship = "Click 'Start Timer' to begin the sequence";
            } else if (currentTime < mainEventTime) {
                relationship = "Events are happening BEFORE the main event";
            } else {
                relationship = "Main event has occurred!";
            }
            
            fill(0);
            textAlign(CENTER);
            textSize(14);
            text(relationship, width/2, height - 30);
            
            // Time display
            textSize(12);
            text("Current time: " + currentTime.toFixed(1) + "s", width/2, height - 10);
        }
        
        function drawTimeline(currentTime) {
            // Timeline background
            fill(255);
            stroke(100);
            strokeWeight(1);
            rect(50, 50, 300, 40);
            
            // Timeline markers
            for (let event of events) {
                let x = map(event.time, 0, 4, 50, 350);
                
                if (event.triggered) {
                    fill(event.color[0], event.color[1], event.color[2]);
                } else {
                    fill(200);
                }
                
                if (event.isMain) {
                    stroke(255, 0, 0);
                    strokeWeight(3);
                } else {
                    stroke(100);
                    strokeWeight(1);
                }
                
                ellipse(x, 70, 12, 12);
                
                // Event labels
                fill(0);
                noStroke();
                textAlign(CENTER);
                textSize(8);
                text(event.time + "s", x, 105);
                
                if (event.triggered) {
                    textSize(7);
                    text(event.message, x, 115);
                }
            }
            
            // Current time indicator
            if (timerRunning) {
                let currentX = map(currentTime, 0, 4, 50, 350);
                currentX = constrain(currentX, 50, 350);
                
                stroke(255, 0, 0);
                strokeWeight(2);
                line(currentX, 40, currentX, 100);
                
                fill(255, 0, 0);
                noStroke();
                ellipse(currentX, 40, 8, 8);
            }
            
            // Timeline labels
            fill(0);
            noStroke();
            textAlign(LEFT);
            textSize(12);
            text("Timeline:", 50, 40);
            textAlign(RIGHT);
            text("4s", 350, 40);
        }
        
        function addParticles(color) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: random(width),
                    y: random(130, 200),
                    vx: random(-2, 2),
                    vy: random(-3, -1),
                    color: color,
                    life: 255,
                    decay: random(3, 6)
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;
                
                if (p.life > 0) {
                    fill(p.color[0], p.color[1], p.color[2], p.life);
                    noStroke();
                    ellipse(p.x, p.y, 6, 6);
                } else {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawEventStatus(currentTime) {
            textAlign(LEFT);
            textSize(11);
            fill(0);
            noStroke();
            
            text("Event Status:", 50, 140);
            
            let y = 155;
            for (let event of events) {
                if (event.triggered) {
                    fill(event.color[0], event.color[1], event.color[2]);
                } else if (timerRunning && currentTime < event.time) {
                    fill(100);
                } else {
                    fill(200);
                }
                
                let status = "";
                if (event.triggered) {
                    status = "✓ " + event.message;
                } else if (timerRunning && currentTime < event.time) {
                    status = "⏳ " + event.message + " (in " + (event.time - currentTime).toFixed(1) + "s)";
                } else {
                    status = "○ " + event.message;
                }
                
                text(status, 50, y);
                y += 15;
            }
            
            // Before/after indicator
            y += 10;
            fill(0);
            if (timerRunning) {
                let beforeEvents = events.filter(e => !e.isMain && currentTime < e.time).length;
                let afterEvents = events.filter(e => !e.isMain && e.triggered).length;
                
                text("Events BEFORE main event: " + beforeEvents, 50, y);
                text("Events completed: " + afterEvents, 50, y + 15);
            }
        }
        
        function drawControls() {
            // Start/Stop button
            if (!timerRunning) {
                fill(100, 200, 100);
                stroke(50, 150, 50);
            } else {
                fill(200, 100, 100);
                stroke(150, 50, 50);
            }
            strokeWeight(2);
            rect(280, 120, 80, 25);
            
            fill(255);
            noStroke();
            textAlign(CENTER);
            textSize(12);
            text(timerRunning ? "Stop" : "Start Timer", 320, 137);
            
            // Reset button
            fill(200);
            stroke(100);
            strokeWeight(1);
            rect(280, 150, 80, 25);
            fill(0);
            text("Reset", 320, 167);
        }
        
        function mousePressed() {
            // Start/Stop button
            if (mouseX > 280 && mouseX < 360 && mouseY > 120 && mouseY < 145) {
                if (!timerRunning) {
                    startTime = millis();
                    timerRunning = true;
                } else {
                    timerRunning = false;
                }
            }
            
            // Reset button
            if (mouseX > 280 && mouseX < 360 && mouseY > 150 && mouseY < 175) {
                timerRunning = false;
                startTime = null;
                particles = [];
                for (let event of events) {
                    event.triggered = false;
                }
            }
        }
    </script>
</body>
</html>
