<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>    <div class="description">
        <h1>Preposition: BEHIND</h1>
        
        <p class="web-editor-link-container">
            <a href="https://editor.p5js.org/npuckett/sketches/l4YaEwM3U" target="_blank" class="web-editor-link">
                Open this sketch in P5 Web Editor →
            </a>
        </p>
        
        <h3>Try It</h3>
        <p>Drag the circles in the canvas below. The concept of "behind" is simulated using layering - one circle can be drawn behind another.</p>
    </div>

    <div class="container">
        <div class="canvas-container">
            <div id="canvas"></div>
        </div>
    </div>

    <div class="description">
        <h3>Concept</h3>
        <p><strong>BEHIND</strong> means positioned at the back of something, obscured or hidden by it. In 2D graphics, this is represented through drawing order and layering - elements drawn first appear behind those drawn later.</p>
        
        <h3>Translation Strategy</h3>
        <p>To create "behind" relationships on screen:</p>
        <ul>
            <li><strong>Drawing Order:</strong> Draw "behind" elements first, "in front" elements last</li>
            <li><strong>Depth Simulation:</strong> Use size, opacity, or color to suggest depth</li>
            <li><strong>Overlap Detection:</strong> Check if elements overlap and manage visibility</li>
        </ul>
        
        <h3>Key P5.js Methods</h3>
        <div class="code-section">
            <strong>Drawing Order:</strong><br>
            • Elements drawn first appear behind elements drawn later<br>
            • Use arrays to control rendering sequence<br><br>
            
            <strong>Position Comparison:</strong><br>
            • <a href="https://p5js.org/reference/p5/dist" target="_blank">dist(x1, y1, x2, y2)</a> - Check if circles overlap<br>
            • Overlap occurs when distance < sum of radii<br><br>
            
            <strong>Visual Depth Cues:</strong><br>
            • <a href="https://p5js.org/reference/p5/fill" target="_blank">fill(r, g, b, alpha)</a> - Use transparency for depth<br>
            • Size variation to suggest distance<br><br>
            
            <strong>Drawing Elements:</strong><br>
            • <a href="https://p5js.org/reference/p5/ellipse" target="_blank">ellipse(x, y, width, height)</a> - Draw circles at specific positions<br>
            • <a href="https://p5js.org/reference/p5/stroke" target="_blank">stroke()</a> - Add outlines for clarity<br><br>
            
            <strong>Mouse Interaction:</strong><br>
            • <a href="https://p5js.org/reference/p5/mousePressed" target="_blank">mousePressed()</a> - Detect when mouse is clicked<br>
            • <a href="https://p5js.org/reference/p5/mouseDragged" target="_blank">mouseDragged()</a> - Detect when mouse is dragged<br>
            • <a href="https://p5js.org/reference/p5/mouseReleased" target="_blank">mouseReleased()</a> - Detect when mouse is released
        </div>
        
        <h3>Code Structure</h3>
        <div class="code-section">
            <strong>Basic Pattern for "Behind":</strong><br><br>
            
            1. <strong>Define depth order:</strong> Create array with depth values<br>
            <code>let circles = [{x: 100, y: 100, depth: 1}, {x: 120, y: 110, depth: 2}];</code><br><br>
            
            2. <strong>Sort by depth:</strong> Arrange elements for proper drawing order<br>
            <code>circles.sort((a, b) => a.depth - b.depth);</code><br><br>
            
            3. <strong>Draw in order:</strong> Render elements from back to front<br>
            <code>for (let circle of circles) { ellipse(circle.x, circle.y, 30, 30); }</code><br><br>
            
            4. <strong>Check overlap:</strong> Detect when one is behind another<br>
            <code>let distance = dist(circleA.x, circleA.y, circleB.x, circleB.y);</code><br>
            <code>let isOverlapping = distance < (circleA.radius + circleB.radius);</code>
        </div>
    </div>    <script>        let circles = [
            { x: 120, y: 150, radius: 25, depth: 1, color: [100, 150, 255], label: "Blue (Back)", dragging: false },
            { x: 280, y: 150, radius: 25, depth: 2, color: [255, 100, 100], label: "Red (Front)", dragging: false }
        ];
        
        function setup() {
            createCanvas(400, 300).parent('canvas');
            // Set consistent depth order - blue circle is always behind (depth 1)
            circles[0].depth = 1; // Blue circle - always behind
            circles[1].depth = 2; // Red circle - always in front
        }
          function draw() {
            background(240);
            
            // Calculate the 3 key variables ALWAYS
            let distance = dist(circles[0].x, circles[0].y, circles[1].x, circles[1].y);
            let radiusSum = circles[0].radius + circles[1].radius;
            let isOverlapping = distance < radiusSum;
            
            // Calculate percentage overlap
            let percentOverlap = 0;
            if (isOverlapping) {
                let overlapDistance = radiusSum - distance;
                let maxPossibleOverlap = Math.min(circles[0].radius, circles[1].radius) * 2;
                percentOverlap = Math.min(100, (overlapDistance / maxPossibleOverlap) * 100);
            }
              // Sort circles by depth (smaller depth = behind)
            let sortedCircles = [...circles].sort((a, b) => a.depth - b.depth);
            let backCircle = sortedCircles[0]; // First in sorted array (lowest depth)
            let frontCircle = sortedCircles[1]; // Second in sorted array (highest depth)
              // Draw distance line between center points - ALWAYS
            stroke(100, 100, 100);
            strokeWeight(2);
            line(backCircle.x, backCircle.y, frontCircle.x, frontCircle.y);
            
            // Draw center points
            fill(50, 50, 50);
            noStroke();
            ellipse(backCircle.x, backCircle.y, 4, 4);
            ellipse(frontCircle.x, frontCircle.y, 4, 4);
            
            // Draw circles in depth order (back to front) - ALWAYS draw both
            for (let circle of sortedCircles) {
                // Determine if this circle is behind or in front
                let isBehind = (circle === backCircle);
                let isFront = (circle === frontCircle);
                
                // Make both circles 50% transparent for better overlap visibility
                fill(circle.color[0], circle.color[1], circle.color[2], 128); // 50% transparency
                
                // Color based on overlap status and position
                if (isOverlapping && isBehind) {
                    stroke(255, 0, 0); // Red stroke for behind circle
                    strokeWeight(3);
                } else if (isOverlapping && isFront) {
                    stroke(0, 150, 0); // Green stroke for front circle
                    strokeWeight(3);
                } else {
                    stroke(0);
                    strokeWeight(2);
                }
                
                ellipse(circle.x, circle.y, circle.radius * 2, circle.radius * 2);
            }
            
            // Draw percentage on the back circle if overlapping
            if (isOverlapping) {
                fill(255, 255, 255);
                stroke(0);
                strokeWeight(1);
                textAlign(CENTER);
                textSize(12);
                text(Math.round(percentOverlap) + "%", backCircle.x, backCircle.y + 2);
                textSize(8);
                text("BEHIND", backCircle.x, backCircle.y - 10);
            }            // Draw labels - ALWAYS
            fill(0);
            noStroke();
            textAlign(CENTER);
            textSize(12);
            for (let circle of circles) {
                // Use the original label since depth is now fixed
                text(circle.label, circle.x, circle.y - circle.radius - 15);
                text("Depth: " + circle.depth, circle.x, circle.y - circle.radius - 5);
            }
            
            // ALWAYS display the 3 key variables
            textAlign(LEFT);
            textSize(12);
            fill(0);
            text("DISTANCE: " + Math.round(distance) + " pixels", 10, 25);
            text("OVERLAPPING: " + (isOverlapping ? "YES" : "NO"), 10, 45);
            text("% OVERLAP: " + Math.round(percentOverlap) + "%", 10, 65);
              // Determine relationship
            let relationship = "";
            if (isOverlapping) {
                let backColor = backCircle.label.split(' ')[0];
                let frontColor = frontCircle.label.split(' ')[0];
                relationship = `${backColor} is ${Math.round(percentOverlap)}% BEHIND ${frontColor}`;
            } else {
                relationship = "No overlap - no behind relationship";
            }
            
            // Draw relationship text
            textAlign(CENTER);
            textSize(16);
            if (isOverlapping) {
                fill(200, 50, 50); // Red when overlapping
            } else {
                fill(100, 100, 100); // Gray when not overlapping
            }
            text(relationship, width/2, height - 40);
              fill(0);
            textSize(12);
            text("Drag circles to change overlap • Blue is always behind, Red is always in front", width/2, height - 15);
        }        function mousePressed() {
            // Check which circle is clicked - only for dragging, not for changing depth
            for (let i = circles.length - 1; i >= 0; i--) {
                let circle = circles[i];
                if (dist(mouseX, mouseY, circle.x, circle.y) < circle.radius) {
                    circle.dragging = true;
                    break;
                }
            }
        }
        
        function mouseDragged() {
            // Update position if dragging
            for (let circle of circles) {
                if (circle.dragging) {
                    circle.x = mouseX;
                    circle.y = mouseY;
                }
            }
        }
        
        function mouseReleased() {
            // Stop dragging
            for (let circle of circles) {
                circle.dragging = false;
            }
        }
    </script>
</body>
</html>
