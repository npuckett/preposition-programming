<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>    <div class="description">
        <h1>Preposition: ALONG</h1>
        
        <p class="web-editor-link-container">
            <a href="https://editor.p5js.org/npuckett/sketches/yIVftMasm" target="_blank" class="web-editor-link">
                Open this sketch in P5 Web Editor →
            </a>
        </p>
        
        <h3>Try It</h3>
        <p>Click the "Start" button to watch the yellow circle move along the curved blue path, following its shape.</p>
    </div>

    <div class="container">
        <div class="canvas-container">
            <div id="canvas"></div>
        </div>
    </div>

    <div class="description">
        <h3>Concept</h3>
        <p><strong>ALONG</strong> means moving in a line or following the length, direction, or course of something. This involves following a path, edge, or boundary rather than crossing it.</p>
        
        <h3>Translation Strategy</h3>
        <p>To create "along" relationships on screen:</p>
        <ul>
            <li><strong>Path Following:</strong> Define a route and move an object step by step along it</li>
            <li><strong>Edge Tracking:</strong> Follow the perimeter or edge of shapes and boundaries</li>
            <li><strong>Sequential Movement:</strong> Move through predefined waypoints in order</li>
        </ul>
        
        <h3>Key P5.js Methods</h3>
        <div class="code-section">
            <strong>Path Definition:</strong><br>
            • Store arrays of points to define complex paths<br>
            • <a href="https://p5js.org/reference/p5/curveVertex" target="_blank">curveVertex(x, y)</a> - Create smooth curved paths<br>
            • <a href="https://p5js.org/reference/p5/bezier" target="_blank">bezier()</a> - Define Bezier curve paths<br><br>
            
            <strong>Path Following:</strong><br>
            • Track current position along path with index or progress value<br>
            • <a href="https://p5js.org/reference/p5/lerp" target="_blank">lerp(start, stop, amount)</a> - Interpolate between path points<br><br>
            
            <strong>Drawing Elements:</strong><br>
            • <a href="https://p5js.org/reference/p5/ellipse" target="_blank">ellipse(x, y, width, height)</a> - Draw moving objects<br>
            • <a href="https://p5js.org/reference/p5/beginShape" target="_blank">beginShape()</a> and <a href="https://p5js.org/reference/p5/endShape" target="_blank">endShape()</a> - Draw complex paths<br>
            • <a href="https://p5js.org/reference/p5/vertex" target="_blank">vertex(x, y)</a> - Define path points<br><br>
            
            <strong>Mathematical Curves:</strong><br>
            • <a href="https://p5js.org/reference/p5/sin" target="_blank">sin()</a> and <a href="https://p5js.org/reference/p5/cos" target="_blank">cos()</a> - Create circular or wave paths<br>
            • Parametric equations for complex curves<br><br>
            
            <strong>Mouse Interaction:</strong><br>
            • <a href="https://p5js.org/reference/p5/mousePressed" target="_blank">mousePressed()</a> - Start or control path following<br>
            • Button controls for animation
        </div>
        
        <h3>Code Structure</h3>
        <div class="code-section">
            <strong>Basic Pattern for "Along":</strong><br><br>
            
            1. <strong>Define path:</strong> Create array of points or mathematical curve<br>
            <code>let pathPoints = [{x: 50, y: 150}, {x: 150, y: 100}, {x: 250, y: 200}, {x: 350, y: 150}];</code><br><br>
            
            2. <strong>Track progress:</strong> Use index or progress value<br>
            <code>let currentIndex = 0;</code><br>
            <code>let progress = 0; // 0 to pathPoints.length - 1</code><br><br>
            
            3. <strong>Calculate position:</strong> Interpolate between path points<br>
            <code>let pointA = pathPoints[Math.floor(progress)];</code><br>
            <code>let pointB = pathPoints[Math.ceil(progress)];</code><br>
            <code>let t = progress - Math.floor(progress);</code><br>
            <code>let x = lerp(pointA.x, pointB.x, t);</code><br><br>
            
            4. <strong>Update movement:</strong> Advance along path<br>
            <code>if (isMoving) { progress += speed; }</code>
        </div>
    </div>

    <script>
        let pathPoints = [];
        let movingCircle = { x: 0, y: 0, radius: 12 };
        let pathProgress = 0;
        let isMoving = false;
        let hasCompleted = false;
        let trail = [];
        
        function setup() {
            createCanvas(400, 300).parent('canvas');
            
            // Create a curved path using sine wave
            for (let i = 0; i <= 100; i++) {
                let x = map(i, 0, 100, 50, 350);
                let y = 150 + sin(map(i, 0, 100, 0, TWO_PI * 2)) * 60;
                pathPoints.push({x: x, y: y});
            }
            
            // Set initial position
            movingCircle.x = pathPoints[0].x;
            movingCircle.y = pathPoints[0].y;
        }
        
        function draw() {
            background(240);
            
            // Update position along path
            if (isMoving && pathProgress < pathPoints.length - 1) {
                pathProgress += 0.8; // Speed along path
                
                let currentIndex = Math.floor(pathProgress);
                let nextIndex = Math.min(currentIndex + 1, pathPoints.length - 1);
                let t = pathProgress - currentIndex;
                
                // Interpolate between current and next point
                movingCircle.x = lerp(pathPoints[currentIndex].x, pathPoints[nextIndex].x, t);
                movingCircle.y = lerp(pathPoints[currentIndex].y, pathPoints[nextIndex].y, t);
                
                // Add to trail
                trail.push({x: movingCircle.x, y: movingCircle.y});
                if (trail.length > 50) {
                    trail.shift();
                }
            } else if (pathProgress >= pathPoints.length - 1 && isMoving) {
                isMoving = false;
                hasCompleted = true;
            }
            
            // Draw the path
            stroke(100, 150, 255);
            strokeWeight(4);
            noFill();
            beginShape();
            for (let point of pathPoints) {
                vertex(point.x, point.y);
            }
            endShape();
            
            // Draw path direction indicators
            stroke(100, 150, 255, 100);
            strokeWeight(1);
            for (let i = 0; i < pathPoints.length; i += 20) {
                let point = pathPoints[i];
                ellipse(point.x, point.y, 6, 6);
            }
            
            // Draw trail of movement
            if (trail.length > 1) {
                stroke(255, 200, 0, 150);
                strokeWeight(3);
                noFill();
                beginShape();
                for (let point of trail) {
                    vertex(point.x, point.y);
                }
                endShape();
            }
            
            // Draw start and end markers
            fill(100, 255, 100);
            noStroke();
            ellipse(pathPoints[0].x, pathPoints[0].y, 16, 16);
            fill(255, 100, 100);
            ellipse(pathPoints[pathPoints.length - 1].x, pathPoints[pathPoints.length - 1].y, 16, 16);
            
            // Draw moving circle
            if (hasCompleted) {
                fill(100, 255, 100);
                stroke(50, 200, 50);
            } else if (isMoving) {
                fill(255, 255, 100);
                stroke(255, 200, 0);
            } else {
                fill(255, 200, 100);
                stroke(255, 150, 0);
            }
            strokeWeight(2);
            ellipse(movingCircle.x, movingCircle.y, movingCircle.radius * 2, movingCircle.radius * 2);
            
            // Draw direction indicator on moving circle
            if (isMoving && pathProgress < pathPoints.length - 2) {
                let nextIndex = Math.min(Math.floor(pathProgress) + 2, pathPoints.length - 1);
                let nextPoint = pathPoints[nextIndex];
                let angle = atan2(nextPoint.y - movingCircle.y, nextPoint.x - movingCircle.x);
                
                stroke(0);
                strokeWeight(2);
                let arrowX = movingCircle.x + cos(angle) * 8;
                let arrowY = movingCircle.y + sin(angle) * 8;
                line(movingCircle.x, movingCircle.y, arrowX, arrowY);
            }
            
            // Labels
            fill(0);
            noStroke();
            textAlign(CENTER);
            textSize(10);
            text("Start", pathPoints[0].x, pathPoints[0].y - 15);
            text("End", pathPoints[pathPoints.length - 1].x, pathPoints[pathPoints.length - 1].y + 20);
            
            // Control buttons
            fill(200);
            stroke(100);
            strokeWeight(1);
            rect(10, 20, 60, 25);
            rect(80, 20, 60, 25);
            
            fill(0);
            noStroke();
            textAlign(CENTER);
            textSize(12);
            text("Start", 40, 37);
            text("Reset", 110, 37);
            
            // Determine relationship
            let relationship = "";
            if (hasCompleted) {
                relationship = "Circle has moved ALONG the entire path";
            } else if (isMoving) {
                relationship = "Circle is moving ALONG the path";
            } else {
                relationship = "Click Start to move along the path";
            }
            
            // Draw measurement info
            textAlign(LEFT);
            textSize(10);
            text("Progress: " + Math.round((pathProgress / (pathPoints.length - 1)) * 100) + "%", 10, 60);
            text("Position on path: " + Math.round(pathProgress), 10, 75);
            text("Following path: " + isMoving, 10, 90);
            
            // Draw relationship text
            textAlign(CENTER);
            textSize(16);
            text(relationship, width/2, height - 40);
            text("Watch the circle follow the curved path", width/2, height - 15);
        }
        
        function mousePressed() {
            // Check if Start button clicked
            if (mouseX > 10 && mouseX < 70 && mouseY > 20 && mouseY < 45) {
                if (!isMoving && !hasCompleted) {
                    isMoving = true;
                    trail = [];
                }
            }
            
            // Check if Reset button clicked
            if (mouseX > 80 && mouseX < 140 && mouseY > 20 && mouseY < 45) {
                pathProgress = 0;
                isMoving = false;
                hasCompleted = false;
                movingCircle.x = pathPoints[0].x;
                movingCircle.y = pathPoints[0].y;
                trail = [];
            }
        }
    </script>
</body>
</html>
