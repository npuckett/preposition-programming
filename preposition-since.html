<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>    <link rel="stylesheet" href="styles.css">
</head>
<body>    <div class="description">
        <h1>Preposition: SINCE</h1>
        
        <p class="web-editor-link-container">
            <a href="https://editor.p5js.org/npuckett/sketches/UdyLk3RHP" target="_blank" class="web-editor-link">
                Open this sketch in P5 Web Editor →
            </a>
        </p>
        
        <h3>Try It</h3>
        <p>Click the buttons below to track accumulating activity since a reference event. Notice how counters grow from the starting point.</p>
    </div>

    <div class="container">
        <div class="canvas-container">
            <div id="sketch-holder"></div>
            <div id="controls">
                <button onclick="startTracking()">Start Tracking</button>
                <button onclick="triggerEvent()">Trigger Event</button>
                <button onclick="resetTracking()">Reset</button>
            </div>
            <div id="status">Tracking: Ready to start</div>
        </div>
    </div>

    <div class="description">
        <h3>Concept</h3>
        <p>The preposition <strong>"since"</strong> indicates the starting point of a time period that continues to the present moment. It establishes a reference point in the past from which something has been ongoing or true. In programming, this involves calculating elapsed time from a specific starting point to track duration and accumulation.</p>        <h3>Translation Strategy</h3>
        <p>To create "since" relationships in time:</p>
        <ul>
            <li><strong>Reference Points:</strong> Establish starting times for ongoing measurements</li>
            <li><strong>Accumulation:</strong> Track changes and growth from the reference point</li>
            <li><strong>Duration Tracking:</strong> Calculate elapsed time from specific moments</li>
        </ul>

        <h3>Key P5.js Methods</h3>
        <div class="code-section">
            <strong>Time Management:</strong><br>
            • <a href="https://p5js.org/reference/p5/millis" target="_blank">millis()</a> - tracks elapsed time for "since" calculations<br>
            • Duration calculations: <code>timeSince = millis() - eventTime</code><br>
            • <a href="https://p5js.org/reference/p5/frameCount" target="_blank">frameCount</a> - alternative counting method<br><br>
            
            <strong>Visual Elements:</strong><br>
            • <a href="https://p5js.org/reference/p5/random" target="_blank">random()</a> - generates ongoing events to count<br>
            • <a href="https://p5js.org/reference/p5/map" target="_blank">map()</a> - visualizes accumulation over time<br>
            • <a href="https://p5js.org/reference/p5/rect" target="_blank">rect()</a> - creates progress bars and counters<br>
            • <a href="https://p5js.org/reference/p5/text" target="_blank">text()</a> - displays duration and count information<br><br>
            
            <strong>Data Tracking:</strong><br>
            • Counter variables for accumulation<br>
            • State management for ongoing processes<br>
            • Visual feedback for continuous activity
        </div>

        <h3>Code Structure</h3>        <div class="code-section">
            <strong>Basic Pattern for "Since":</strong><br><br>
            
            1. <strong>Setup tracking variables:</strong> Store reference time and counters<br>
            <code>let tracking = {</code><br>
            <code>&nbsp;&nbsp;eventTime: null,</code><br>
            <code>&nbsp;&nbsp;counters: {steps: 0, notifications: 0}</code><br>
            <code>};</code><br><br>
            
            2. <strong>Calculate time since event:</strong> Duration from reference<br>
            <code>function getTimeSince() {</code><br>
            <code>&nbsp;&nbsp;if (!tracking.eventTime) return 0;</code><br>
            <code>&nbsp;&nbsp;return millis() - tracking.eventTime;</code><br>
            <code>}</code><br><br>
            
            3. <strong>Update counters since event:</strong> Accumulate values<br>
            <code>if (tracking.eventTime && tracking.running) {</code><br>
            <code>&nbsp;&nbsp;// Continuous accumulation since the event</code><br>
            <code>&nbsp;&nbsp;if (frameCount % 60 === 0) {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;tracking.counters.steps++;</code><br>
            <code>&nbsp;&nbsp;}</code><br>
            <code>}</code>
        </div>
    </div>

    <script>
        let tracking = {
            startTime: null,
            eventTime: null,
            running: false,
            counters: {
                steps: 0,
                notifications: 0,
                points: 0,
                heartbeats: 0
            }
        };

        let particles = [];
        let notifications = [];

        function setup() {
            let canvas = createCanvas(600, 400);
            canvas.parent('sketch-holder');
            textAlign(CENTER, CENTER);
            textSize(14);
        }

        function draw() {
            background(240, 248, 255);
            
            if (tracking.running) {
                updateCountersSince();
                drawTrackingDisplay();
                drawVisualizations();
                updateStatus();
            } else {
                drawInstructions();
            }
        }

        function updateCountersSince() {
            if (tracking.eventTime && tracking.running) {
                // Steps counter (every second)
                if (frameCount % 60 === 0) {
                    tracking.counters.steps++;
                }
                
                // Notifications (random intervals)
                if (frameCount % 180 === 0 && random() < 0.7) {
                    tracking.counters.notifications++;
                    notifications.push({
                        x: random(50, width - 50),
                        y: 100,
                        age: 0
                    });
                }
                
                // Points (continuous accumulation)
                if (frameCount % 30 === 0) {
                    tracking.counters.points += Math.floor(random(1, 4));
                }
                
                // Heartbeats (regular intervals)
                if (frameCount % 45 === 0) {
                    tracking.counters.heartbeats++;
                }
            }
        }

        function drawTrackingDisplay() {
            let timeSince = getTimeSince();
            let secondsSince = timeSince / 1000;
            
            // Title
            fill(0);
            textSize(18);
            text("Activity Since Event", width/2, 30);
            
            // Time since display
            textSize(16);
            if (tracking.eventTime) {
                fill(0, 100, 200);
                text("Time Since Event: " + secondsSince.toFixed(1) + " seconds", width/2, 60);
            } else {
                fill(150);
                text("No event triggered yet", width/2, 60);
            }
            
            // Counter displays
            let startY = 120;
            let counterHeight = 50;
            textAlign(LEFT, CENTER);
            textSize(14);
            
            let counterNames = ["Steps", "Notifications", "Points", "Heartbeats"];
            let counterKeys = ["steps", "notifications", "points", "heartbeats"];
            let counterColors = [
                [100, 200, 100],
                [255, 150, 100],
                [100, 150, 255],
                [255, 100, 150]
            ];
            
            for (let i = 0; i < counterNames.length; i++) {
                let y = startY + i * counterHeight;
                let count = tracking.counters[counterKeys[i]];
                
                // Label
                fill(0);
                text(counterNames[i] + " since event:", 50, y);
                
                // Count
                fill(counterColors[i]);
                textSize(20);
                text(count, 250, y);
                
                // Progress bar
                let barWidth = map(count, 0, 50, 0, 200);
                fill(counterColors[i][0], counterColors[i][1], counterColors[i][2], 100);
                noStroke();
                rect(300, y - 10, barWidth, 20);
                
                // Bar outline
                stroke(counterColors[i]);
                strokeWeight(2);
                noFill();
                rect(300, y - 10, 200, 20);
                
                textSize(14);
            }
            
            textAlign(CENTER, CENTER);
        }

        function drawVisualizations() {
            // Animated particles showing continuous activity
            if (tracking.eventTime && frameCount % 10 === 0) {
                particles.push({
                    x: random(width),
                    y: height - 50,
                    vx: random(-2, 2),
                    vy: random(-3, -1),
                    life: 60,
                    color: [random(100, 255), random(100, 255), random(100, 255)]
                });
            }
            
            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                fill(p.color[0], p.color[1], p.color[2], map(p.life, 0, 60, 0, 255));
                noStroke();
                circle(p.x, p.y, 5);
                
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Draw notifications
            for (let i = notifications.length - 1; i >= 0; i--) {
                let notif = notifications[i];
                fill(255, 150, 100);
                noStroke();
                textSize(20);
                text("📧", notif.x, notif.y - notif.age);
                
                notif.age += 2;
                if (notif.age > 80) {
                    notifications.splice(i, 1);
                }
            }
            textSize(14);
            
            // Timeline visualization
            if (tracking.startTime && tracking.eventTime) {
                let totalElapsed = millis() - tracking.startTime;
                let eventElapsed = millis() - tracking.eventTime;
                
                // Timeline base
                stroke(150);
                strokeWeight(3);
                let timelineY = height - 30;
                line(50, timelineY, width - 50, timelineY);
                
                // Event marker
                let eventX = map(tracking.eventTime - tracking.startTime, 0, totalElapsed, 50, width - 50);
                fill(255, 0, 0);
                noStroke();
                circle(eventX, timelineY, 12);
                
                // Since period highlight
                let currentX = map(totalElapsed, 0, totalElapsed, 50, width - 50);
                fill(0, 200, 100, 100);
                rect(eventX, timelineY - 5, currentX - eventX, 10);
                
                // Labels
                fill(0);
                text("Event", eventX, timelineY - 20);
                text("Since", (eventX + currentX) / 2, timelineY + 20);
            }
        }

        function drawInstructions() {
            fill(100);
            text("Click 'Start Tracking' to begin monitoring", width/2, height/2 - 60);
            text("Then click 'Trigger Event' to set the 'since' reference point", width/2, height/2 - 30);
            text("Watch counters accumulate from that moment forward", width/2, height/2);
            
            // Preview counters
            textAlign(LEFT, CENTER);
            fill(150);
            text("Steps since event: 0", 100, height/2 + 40);
            text("Notifications since event: 0", 100, height/2 + 60);
            text("Points since event: 0", 100, height/2 + 80);
            text("Heartbeats since event: 0", 100, height/2 + 100);
            textAlign(CENTER, CENTER);
        }

        function getTimeSince() {
            if (!tracking.eventTime) return 0;
            return millis() - tracking.eventTime;
        }

        function updateStatus() {
            let status = "";
            
            if (!tracking.eventTime) {
                status = "Tracking started - waiting for event trigger";
            } else {
                let timeSince = getTimeSince();
                status = "Tracking activity since event (" + (timeSince/1000).toFixed(1) + "s ago)";
            }
            
            document.getElementById('status').innerHTML = status;
        }

        function startTracking() {
            tracking.startTime = millis();
            tracking.running = true;
            tracking.eventTime = null;
            resetCounters();
        }

        function triggerEvent() {
            if (tracking.running) {
                tracking.eventTime = millis();
                resetCounters();
            }
        }

        function resetTracking() {
            tracking.running = false;
            tracking.startTime = null;
            tracking.eventTime = null;
            resetCounters();
            particles = [];
            notifications = [];
            document.getElementById('status').innerHTML = "Tracking: Ready to start";
        }

        function resetCounters() {
            tracking.counters.steps = 0;
            tracking.counters.notifications = 0;
            tracking.counters.points = 0;
            tracking.counters.heartbeats = 0;
        }
    </script>
</body>
</html>
