<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>    <link rel="stylesheet" href="styles.css">
</head>
<body>    <div class="description">
        <h1>Preposition: ONTO</h1>
        
        <p class="web-editor-link-container">
            <a href="https://editor.p5js.org/npuckett/sketches/sWthbYYs3" target="_blank" class="web-editor-link">
                Open this sketch in P5 Web Editor →
            </a>
        </p>
        
        <h3>Try It</h3>
        <p>Click the "Start" button to watch the yellow circle move onto the blue platform, landing on its surface.</p>
    </div>

    <div class="container">
        <div class="canvas-container">
            <div id="canvas"></div>
        </div>
    </div>

    <div class="description">
        <h3>Concept</h3>
        <p><strong>ONTO</strong> means moving to a position on the surface or top of something. This implies landing on, climbing on, or being placed on top of another object.</p>
        
        <h3>Translation Strategy</h3>
        <p>To create "onto" relationships on screen:</p>
        <ul>
            <li><strong>Surface Contact:</strong> Position objects so they rest on the surface of other objects</li>
            <li><strong>Vertical Landing:</strong> Show movement that ends with contact on the top surface</li>
            <li><strong>Support Relationship:</strong> The object "onto" should appear supported by the surface</li>
        </ul>
        
        <h3>Key P5.js Methods</h3>
        <div class="code-section">
            <strong>Position Calculation:</strong><br>
            • Calculate surface positions: <code>objectY = surfaceY - objectRadius</code><br>
            • Account for object size when positioning on surfaces<br><br>
            
            <strong>Collision Detection:</strong><br>
            • Detect when objects reach surface level<br>
            • <a href="https://p5js.org/reference/p5/dist" target="_blank">dist(x1, y1, x2, y2)</a> - Check proximity to landing surface<br><br>
            
            <strong>Drawing Elements:</strong><br>
            • <a href="https://p5js.org/reference/p5/rect" target="_blank">rect(x, y, width, height)</a> - Draw platforms and surfaces<br>
            • <a href="https://p5js.org/reference/p5/ellipse" target="_blank">ellipse(x, y, width, height)</a> - Draw objects that land onto surfaces<br><br>
            
            <strong>Animation:</strong><br>
            • <a href="https://p5js.org/reference/p5/lerp" target="_blank">lerp(start, stop, amount)</a> - Smooth landing animation<br>
            • Gravity simulation for realistic landing motion<br><br>
            
            <strong>Visual Effects:</strong><br>
            • Shadow effects to show contact with surface<br>
            • Bounce or settling animation on landing<br><br>
            
            <strong>Mouse Interaction:</strong><br>
            • <a href="https://p5js.org/reference/p5/mousePressed" target="_blank">mousePressed()</a> - Trigger landing animation<br>
            • Button controls for repeated demonstrations
        </div>
        
        <h3>Code Structure</h3>
        <div class="code-section">
            <strong>Basic Pattern for "Onto":</strong><br><br>
            
            1. <strong>Define surface and starting position:</strong> Set up platform and initial location<br>
            <code>let platform = {x: 200, y: 200, width: 120, height: 20};</code><br>
            <code>let startPoint = {x: 100, y: 50};</code><br>
            <code>let landingPoint = {x: 200, y: platform.y - objectRadius};</code><br><br>
            
            2. <strong>Calculate landing position:</strong> Position on surface<br>
            <code>let surfaceY = platform.y;</code><br>
            <code>let ontoY = surfaceY - movingObject.radius; // Sit on top</code><br><br>
            
            3. <strong>Animate landing:</strong> Move to surface position<br>
            <code>if (isLanding && progress < 1) {</code><br>
            <code>&nbsp;&nbsp;progress += speed;</code><br>
            <code>&nbsp;&nbsp;object.x = lerp(startPoint.x, landingPoint.x, progress);</code><br>
            <code>&nbsp;&nbsp;object.y = lerp(startPoint.y, landingPoint.y, progress);</code><br>
            <code>}</code><br><br>
            
            4. <strong>Detect landing completion:</strong> Check surface contact<br>
            <code>let isOnSurface = (object.y + object.radius >= platform.y);</code><br>
            <code>if (isOnSurface) { hasLanded = true; }</code>
        </div>
    </div>

    <script>
        let platform = { x: 250, y: 200, width: 120, height: 25 };
        let movingCircle = { x: 80, y: 80, radius: 15 };
        let startPoint = { x: 80, y: 80 };
        let landingPoint = { x: 250, y: 0 }; // Will be calculated
        let progress = 0;
        let isLanding = false;
        let hasLanded = false;
        let trail = [];
        let bounceOffset = 0;
        let bounceSpeed = 0;
        
        function setup() {
            createCanvas(400, 300).parent('canvas');
            
            // Calculate proper landing position (on top of platform)
            landingPoint.y = platform.y - movingCircle.radius;
        }
        
        function draw() {
            background(240);
            
            // Update landing animation
            if (isLanding && progress < 1) {
                progress += 0.02; // Speed of landing
                
                // Use easing for more natural landing motion
                let easedProgress = easeInQuad(progress);
                movingCircle.x = lerp(startPoint.x, landingPoint.x, easedProgress);
                movingCircle.y = lerp(startPoint.y, landingPoint.y, easedProgress);
                
                // Add to trail
                trail.push({x: movingCircle.x, y: movingCircle.y});
                if (trail.length > 60) {
                    trail.shift();
                }
            } else if (progress >= 1 && isLanding) {
                isLanding = false;
                hasLanded = true;
                bounceSpeed = -5; // Start bounce
            }
            
            // Handle landing bounce effect
            if (hasLanded) {
                bounceOffset += bounceSpeed;
                bounceSpeed += 0.5; // Gravity
                
                // Stop bouncing when settled
                if (bounceOffset > 0) {
                    bounceOffset = 0;
                    bounceSpeed = bounceSpeed * -0.6; // Damping
                    if (abs(bounceSpeed) < 0.5) {
                        bounceSpeed = 0;
                    }
                }
                
                movingCircle.y = landingPoint.y + bounceOffset;
            }
            
            // Check if circle is on the platform
            let isOnPlatform = (movingCircle.x > platform.x - platform.width/2 && 
                              movingCircle.x < platform.x + platform.width/2 && 
                              movingCircle.y + movingCircle.radius >= platform.y - 5);
            
            // Draw platform
            fill(100, 150, 255);
            stroke(70, 120, 220);
            strokeWeight(3);
            rectMode(CENTER);
            rect(platform.x, platform.y + platform.height/2, platform.width, platform.height);
            
            // Draw platform surface line
            stroke(70, 120, 220);
            strokeWeight(4);
            line(platform.x - platform.width/2, platform.y, 
                 platform.x + platform.width/2, platform.y);
            
            // Draw movement trail
            if (trail.length > 1) {
                stroke(255, 200, 0, 150);
                strokeWeight(3);
                noFill();
                beginShape();
                for (let point of trail) {
                    vertex(point.x, point.y);
                }
                endShape();
                
                // Draw trajectory arc
                if (isLanding) {
                    stroke(255, 200, 0, 100);
                    strokeWeight(1);
                    noFill();
                    beginShape();
                    for (let i = 0; i <= 20; i++) {
                        let t = i / 20;
                        let x = lerp(startPoint.x, landingPoint.x, t);
                        let y = lerp(startPoint.y, landingPoint.y, easeInQuad(t));
                        vertex(x, y);
                    }
                    endShape();
                }
            }
            
            // Draw shadow when on platform
            if (isOnPlatform) {
                fill(0, 0, 0, 50);
                noStroke();
                ellipse(movingCircle.x, platform.y + 3, movingCircle.radius * 1.5, movingCircle.radius * 0.5);
            }
            
            // Draw start point marker
            fill(100, 255, 100);
            noStroke();
            ellipse(startPoint.x, startPoint.y, 12, 12);
            
            // Draw target landing area
            if (!hasLanded) {
                noFill();
                stroke(255, 100, 100, 150);
                strokeWeight(2);
                ellipse(landingPoint.x, landingPoint.y, movingCircle.radius * 2, movingCircle.radius * 2);
            }
            
            // Draw moving circle with state-based coloring
            if (hasLanded && isOnPlatform) {
                fill(100, 255, 100);
                stroke(50, 200, 50);
            } else if (isOnPlatform) {
                fill(255, 255, 100);
                stroke(255, 200, 0);
            } else {
                fill(255, 200, 100);
                stroke(255, 150, 0);
            }
            strokeWeight(2);
            ellipse(movingCircle.x, movingCircle.y, movingCircle.radius * 2, movingCircle.radius * 2);
            
            // Labels
            fill(0);
            noStroke();
            textAlign(CENTER);
            textSize(12);
            text("Start", startPoint.x, startPoint.y - 15);
            text("Platform", platform.x, platform.y + platform.height + 15);
            text("Moving Circle", movingCircle.x, movingCircle.y - movingCircle.radius - 10);
            
            // Control buttons
            fill(200);
            stroke(100);
            strokeWeight(1);
            rect(40, 32.5, 60, 25);
            rect(110, 32.5, 60, 25);
            
            fill(0);
            noStroke();
            textAlign(CENTER);
            textSize(12);
            text("Start", 40, 37);
            text("Reset", 110, 37);
            
            // Determine relationship
            let relationship = "";
            if (hasLanded && isOnPlatform) {
                relationship = "Circle has landed ONTO the platform";
            } else if (isLanding) {
                relationship = "Circle is moving ONTO the platform";
            } else if (isOnPlatform) {
                relationship = "Circle is ON the platform";
            } else {
                relationship = "Click Start to move onto the platform";
            }
            
            // Draw measurement info
            textAlign(LEFT);
            textSize(10);
            text("Platform Y: " + platform.y, 10, 60);
            text("Circle Y: " + Math.round(movingCircle.y), 10, 75);
            text("On platform: " + isOnPlatform, 10, 90);
            text("Has landed: " + hasLanded, 10, 105);
            
            // Draw relationship text
            textAlign(CENTER);
            textSize(16);
            text(relationship, width/2, height - 40);
            text("Watch the circle land on the platform surface", width/2, height - 15);
        }
        
        // Easing function for natural landing motion
        function easeInQuad(t) {
            return t * t;
        }
        
        function mousePressed() {
            // Check if Start button clicked
            if (mouseX > 10 && mouseX < 70 && mouseY > 20 && mouseY < 45) {
                if (!isLanding && !hasLanded) {
                    isLanding = true;
                    progress = 0;
                    trail = [];
                }
            }
            
            // Check if Reset button clicked
            if (mouseX > 80 && mouseX < 140 && mouseY > 20 && mouseY < 45) {
                progress = 0;
                isLanding = false;
                hasLanded = false;
                bounceOffset = 0;
                bounceSpeed = 0;
                movingCircle.x = startPoint.x;
                movingCircle.y = startPoint.y;
                trail = [];
            }
        }
    </script>
</body>
</html>
