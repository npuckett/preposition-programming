<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>    <div class="description">
        <h1>Preposition: AROUND</h1>
        
        <p class="web-editor-link-container">
            <a href="https://editor.p5js.org/npuckett/sketches/KZc6sFR8I" target="_blank" class="web-editor-link">
                Open this sketch in P5 Web Editor →
            </a>
        </p>
        
        <h3>Try It</h3>
        <p>Click the "Start" button to watch the yellow circle move around the blue obstacle in a circular path.</p>
    </div>

    <div class="container">
        <div class="canvas-container">
            <div id="canvas"></div>
        </div>
    </div>

    <div class="description">
        <h3>Concept</h3>
        <p><strong>AROUND</strong> means moving in a circular or curved path that goes about or encircles something, typically avoiding or surrounding an obstacle.</p>
        
        <h3>Translation Strategy</h3>
        <p>To create "around" relationships on screen:</p>
        <ul>
            <li><strong>Circular Motion:</strong> Use trigonometric functions to create circular paths</li>
            <li><strong>Obstacle Avoidance:</strong> Plan paths that go around barriers rather than through them</li>
            <li><strong>Orbital Movement:</strong> Create movement that circles around a central point or object</li>
        </ul>
        
        <h3>Key P5.js Methods</h3>
        <div class="code-section">
            <strong>Trigonometric Functions:</strong><br>
            • <a href="https://p5js.org/reference/p5/sin" target="_blank">sin(angle)</a> and <a href="https://p5js.org/reference/p5/cos" target="_blank">cos(angle)</a> - Create circular motion<br>
            • <code>x = centerX + cos(angle) * radius</code><br>
            • <code>y = centerY + sin(angle) * radius</code><br><br>
            
            <strong>Angle Management:</strong><br>
            • Increment angle over time: <code>angle += speed</code><br>
            • <a href="https://p5js.org/reference/p5/TWO_PI" target="_blank">TWO_PI</a> - Full circle in radians<br>
            • <a href="https://p5js.org/reference/p5/map" target="_blank">map(value, start1, stop1, start2, stop2)</a> - Convert between angle ranges<br><br>
            
            <strong>Drawing Elements:</strong><br>
            • <a href="https://p5js.org/reference/p5/ellipse" target="_blank">ellipse(x, y, width, height)</a> - Draw circular paths and obstacles<br>
            • <a href="https://p5js.org/reference/p5/arc" target="_blank">arc(x, y, w, h, start, stop)</a> - Draw partial circles<br><br>
            
            <strong>Path Visualization:</strong><br>
            • Store previous positions to show orbital trail<br>
            • Draw predicted or guide circles for the path<br><br>
            
            <strong>Mouse Interaction:</strong><br>
            • <a href="https://p5js.org/reference/p5/mousePressed" target="_blank">mousePressed()</a> - Start or control orbital motion<br>
            • Button controls for animation speed and direction
        </div>
        
        <h3>Code Structure</h3>
        <div class="code-section">
            <strong>Basic Pattern for "Around":</strong><br><br>
            
            1. <strong>Define center and radius:</strong> Set up circular motion parameters<br>
            <code>let center = {x: 200, y: 150};</code><br>
            <code>let orbitRadius = 80;</code><br>
            <code>let angle = 0;</code><br><br>
            
            2. <strong>Calculate circular position:</strong> Use trigonometry<br>
            <code>let x = center.x + cos(angle) * orbitRadius;</code><br>
            <code>let y = center.y + sin(angle) * orbitRadius;</code><br><br>
            
            3. <strong>Update angle:</strong> Create continuous motion<br>
            <code>if (isOrbiting) {</code><br>
            <code>&nbsp;&nbsp;angle += 0.05; // Speed of rotation</code><br>
            <code>&nbsp;&nbsp;if (angle > TWO_PI) angle = 0; // Reset after full circle</code><br>
            <code>}</code><br><br>
            
            4. <strong>Track completion:</strong> Detect full orbits<br>
            <code>let completedOrbits = Math.floor(angle / TWO_PI);</code>
        </div>
    </div>

    <script>
        let obstacle = { x: 200, y: 150, radius: 40 };
        let orbitRadius = 80;
        let movingCircle = { x: 0, y: 0, radius: 12 };
        let angle = 0;
        let isOrbiting = false;
        let hasCompletedOrbit = false;
        let trail = [];
        let orbitsCompleted = 0;
        
        function setup() {
            createCanvas(400, 300).parent('canvas');
            
            // Set initial position
            movingCircle.x = obstacle.x + orbitRadius;
            movingCircle.y = obstacle.y;
        }
        
        function draw() {
            background(240);
            
            // Update orbital motion
            if (isOrbiting) {
                angle += 0.03; // Speed of rotation
                
                // Calculate new position around obstacle
                movingCircle.x = obstacle.x + cos(angle) * orbitRadius;
                movingCircle.y = obstacle.y + sin(angle) * orbitRadius;
                
                // Add to trail
                trail.push({x: movingCircle.x, y: movingCircle.y});
                if (trail.length > 120) {
                    trail.shift();
                }
                
                // Check for completed orbits
                let newOrbitsCompleted = Math.floor(angle / TWO_PI);
                if (newOrbitsCompleted > orbitsCompleted) {
                    orbitsCompleted = newOrbitsCompleted;
                    hasCompletedOrbit = true;
                }
            }
            
            // Draw orbital path guide
            noFill();
            stroke(200, 200, 200, 150);
            strokeWeight(2);
            ellipse(obstacle.x, obstacle.y, orbitRadius * 2, orbitRadius * 2);
            
            // Draw movement trail
            if (trail.length > 1) {
                stroke(255, 200, 0, 150);
                strokeWeight(3);
                noFill();
                beginShape();
                for (let point of trail) {
                    vertex(point.x, point.y);
                }
                endShape();
                
                // Draw trail fade effect
                for (let i = 0; i < trail.length; i++) {
                    let alpha = map(i, 0, trail.length - 1, 50, 255);
                    fill(255, 200, 0, alpha);
                    noStroke();
                    let size = map(i, 0, trail.length - 1, 2, 6);
                    ellipse(trail[i].x, trail[i].y, size, size);
                }
            }
            
            // Draw obstacle (central object)
            fill(100, 150, 255);
            stroke(70, 120, 220);
            strokeWeight(3);
            ellipse(obstacle.x, obstacle.y, obstacle.radius * 2, obstacle.radius * 2);
            
            // Draw directional indicators on orbital path
            if (isOrbiting) {
                stroke(100, 200, 100);
                strokeWeight(2);
                let arrowAngle = angle + 0.3;
                let arrowX = obstacle.x + cos(arrowAngle) * orbitRadius;
                let arrowY = obstacle.y + sin(arrowAngle) * orbitRadius;
                let arrowEndX = arrowX + cos(arrowAngle + HALF_PI) * 15;
                let arrowEndY = arrowY + sin(arrowAngle + HALF_PI) * 15;
                line(arrowX, arrowY, arrowEndX, arrowEndY);
                
                // Arrow head
                let headX = arrowEndX + cos(arrowAngle + HALF_PI + 0.5) * 8;
                let headY = arrowEndY + sin(arrowAngle + HALF_PI + 0.5) * 8;
                line(arrowEndX, arrowEndY, headX, headY);
                headX = arrowEndX + cos(arrowAngle + HALF_PI - 0.5) * 8;
                headY = arrowEndY + sin(arrowAngle + HALF_PI - 0.5) * 8;
                line(arrowEndX, arrowEndY, headX, headY);
            }
            
            // Draw moving circle
            if (hasCompletedOrbit) {
                fill(100, 255, 100);
                stroke(50, 200, 50);
            } else if (isOrbiting) {
                fill(255, 255, 100);
                stroke(255, 200, 0);
            } else {
                fill(255, 200, 100);
                stroke(255, 150, 0);
            }
            strokeWeight(2);
            ellipse(movingCircle.x, movingCircle.y, movingCircle.radius * 2, movingCircle.radius * 2);
            
            // Labels
            fill(0);
            noStroke();
            textAlign(CENTER);
            textSize(12);
            text("Obstacle", obstacle.x, obstacle.y + obstacle.radius + 20);
            text("Orbiting Object", movingCircle.x, movingCircle.y - movingCircle.radius - 10);
            
            // Control buttons
            fill(200);
            stroke(100);
            strokeWeight(1);
            rect(10, 20, 60, 25);
            rect(80, 20, 60, 25);
            
            fill(0);
            noStroke();
            textAlign(CENTER);
            textSize(12);
            text("Start", 40, 37);
            text("Reset", 110, 37);
            
            // Determine relationship
            let relationship = "";
            if (hasCompletedOrbit) {
                relationship = `Circle has moved AROUND the obstacle (${orbitsCompleted} orbit${orbitsCompleted > 1 ? 's' : ''})`;
            } else if (isOrbiting) {
                let progress = Math.round((angle / TWO_PI) * 100);
                relationship = `Circle is moving AROUND the obstacle (${progress}%)`;
            } else {
                relationship = "Click Start to orbit around the obstacle";
            }
            
            // Draw measurement info
            textAlign(LEFT);
            textSize(10);
            text("Angle: " + Math.round(degrees(angle)) + "°", 10, 60);
            text("Orbit radius: " + orbitRadius + " pixels", 10, 75);
            text("Orbits completed: " + orbitsCompleted, 10, 90);
            
            // Draw relationship text
            textAlign(CENTER);
            textSize(16);
            text(relationship, width/2, height - 40);
            text("Watch the circle orbit around the central obstacle", width/2, height - 15);
        }
        
        function mousePressed() {
            // Check if Start button clicked
            if (mouseX > 10 && mouseX < 70 && mouseY > 20 && mouseY < 45) {
                if (!isOrbiting) {
                    isOrbiting = true;
                    trail = [];
                }
            }
            
            // Check if Reset button clicked
            if (mouseX > 80 && mouseX < 140 && mouseY > 20 && mouseY < 45) {
                angle = 0;
                isOrbiting = false;
                hasCompletedOrbit = false;
                orbitsCompleted = 0;
                movingCircle.x = obstacle.x + orbitRadius;
                movingCircle.y = obstacle.y;
                trail = [];
            }
        }
    </script>
</body>
</html>
