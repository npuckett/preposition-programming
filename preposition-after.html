<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>    <div class="description">
        <h1>Preposition: AFTER</h1>
        
        <p class="web-editor-link-container">
            <a href="https://editor.p5js.org/npuckett/sketches/GzGonI_p9" target="_blank" class="web-editor-link">
                Open this sketch in P5 Web Editor →
            </a>
        </p>
        
        <h3>Try It</h3>
        <p>Click the buttons below to watch events occur after the main event. Notice how the timing relationships unfold.</p>
    </div>

    <div class="container">
        <div class="canvas-container">
            <div id="sketch-holder"></div>
            <div id="controls">
                <button onclick="startTimeline()">Start Timeline</button>
                <button onclick="resetTimeline()">Reset</button>
            </div>
            <div id="status">Timeline: Ready to start</div>
        </div>
    </div>

    <div class="description">
        <h3>Concept</h3>
        <p>The preposition <strong>"after"</strong> indicates that something happens following a specific point in time or event. It establishes a temporal sequence where one action or state occurs subsequent to another. In programming, this often involves tracking time or counting events to trigger actions in sequence.</p>        <h3>Translation Strategy</h3>
        <p>To create "after" relationships in time:</p>
        <ul>
            <li><strong>Event Sequencing:</strong> Schedule events to occur following a main event</li>
            <li><strong>Time Delays:</strong> Use elapsed time calculations to trigger delayed actions</li>
            <li><strong>State Management:</strong> Track which events have occurred and when</li>
        </ul>

        <h3>Key P5.js Methods</h3>        <div class="code-section">
            <strong>Time Management:</strong><br>
            • <a href="https://p5js.org/reference/p5/millis" target="_blank">millis()</a> - tracks elapsed time since sketch started<br>
            • Time calculations: <code>elapsedTime = millis() - startTime</code><br>
            • <a href="https://p5js.org/reference/p5/frameCount" target="_blank">frameCount</a> - alternative timing method<br><br>
            
            <strong>Visual Elements:</strong><br>
            • <a href="https://p5js.org/reference/p5/fill" target="_blank">fill()</a> - sets colors for visual feedback<br>
            • <a href="https://p5js.org/reference/p5/circle" target="_blank">circle()</a> - draws event markers<br>
            • <a href="https://p5js.org/reference/p5/text" target="_blank">text()</a> - displays timing information<br>
            • <a href="https://p5js.org/reference/p5/rect" target="_blank">rect()</a> - creates timeline visualization<br><br>
            
            <strong>Animation:</strong><br>
            • Progress bars and timeline indicators<br>
            • State-based color changes<br>
            • Sequential event triggering
        </div>

        <h3>Code Structure</h3>        <div class="code-section">
            <strong>Basic Pattern for "After":</strong><br><br>
            
            1. <strong>Setup timing variables:</strong> Track start time and main event<br>
            <code>let timeline = {</code><br>
            <code>&nbsp;&nbsp;startTime: null,</code><br>
            <code>&nbsp;&nbsp;mainEventTime: 3000, // 3 seconds</code><br>
            <code>&nbsp;&nbsp;afterEvents: [...]</code><br>
            <code>};</code><br><br>
            
            2. <strong>Calculate elapsed time:</strong> Monitor current time<br>
            <code>let elapsed = millis() - timeline.startTime;</code><br><br>
            
            3. <strong>Check temporal relationships:</strong> Compare times<br>
            <code>let mainEventPassed = elapsed >= timeline.mainEventTime;</code><br><br>
            
            4. <strong>Trigger after events:</strong> Schedule delayed actions<br>
            <code>if (mainEventPassed) {</code><br>
            <code>&nbsp;&nbsp;let afterTime = timeline.mainEventTime + event.delay;</code><br>
            <code>&nbsp;&nbsp;if (elapsed >= afterTime) {</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;// This happens AFTER the main event</code><br>
            <code>&nbsp;&nbsp;&nbsp;&nbsp;event.triggered = true;</code><br>
            <code>&nbsp;&nbsp;}</code><br>
            <code>}</code>
        </div>
    </div>

    <script>
        let timeline = {
            startTime: null,
            running: false,
            mainEventTime: 3000, // 3 seconds
            afterEvents: [
                {delay: 1000, triggered: false, name: "First after event"},
                {delay: 2500, triggered: false, name: "Second after event"},
                {delay: 4000, triggered: false, name: "Final after event"}
            ]
        };

        function setup() {
            let canvas = createCanvas(600, 400);
            canvas.parent('sketch-holder');
            textAlign(CENTER, CENTER);
            textSize(14);
        }

        function draw() {
            background(240, 248, 255);
            
            if (timeline.running) {
                checkAfterEvents();
                drawTimeline();
                updateStatus();
            } else {
                drawInstructions();
            }
        }

        function checkAfterEvents() {
            let elapsed = millis() - timeline.startTime;
            let mainEventPassed = elapsed >= timeline.mainEventTime;
            
            if (mainEventPassed) {
                for (let event of timeline.afterEvents) {
                    let afterTime = timeline.mainEventTime + event.delay;
                    if (elapsed >= afterTime && !event.triggered) {
                        event.triggered = true;
                    }
                }
            }
        }

        function drawTimeline() {
            let elapsed = millis() - timeline.startTime;
            
            // Timeline base
            stroke(100);
            strokeWeight(3);
            line(50, height/2, width-50, height/2);
            
            // Time markers
            let timelineWidth = width - 100;
            let maxTime = 8000; // 8 seconds total
            
            // Main event marker
            let mainEventX = map(timeline.mainEventTime, 0, maxTime, 50, width-50);
            if (elapsed >= timeline.mainEventTime) {
                fill(0, 100, 200);
            } else {
                fill(150);
            }
            noStroke();
            circle(mainEventX, height/2, 20);
            fill(0);
            text("Main Event\n(3s)", mainEventX, height/2 - 40);
            
            // After event markers
            for (let i = 0; i < timeline.afterEvents.length; i++) {
                let event = timeline.afterEvents[i];
                let eventTime = timeline.mainEventTime + event.delay;
                let eventX = map(eventTime, 0, maxTime, 50, width-50);
                
                if (event.triggered) {
                    fill(0, 200, 100); // Green for triggered
                } else if (elapsed >= timeline.mainEventTime) {
                    fill(255, 150, 0); // Orange if waiting
                } else {
                    fill(200); // Gray if not ready
                }
                
                noStroke();
                circle(eventX, height/2, 15);
                fill(0);
                text(event.name + "\n(+" + (event.delay/1000) + "s)", eventX, height/2 + 40);
            }
            
            // Current time indicator
            let currentX = map(elapsed, 0, maxTime, 50, width-50);
            if (currentX <= width-50) {
                stroke(255, 0, 0);
                strokeWeight(2);
                line(currentX, height/2 - 60, currentX, height/2 + 60);
                fill(255, 0, 0);
                noStroke();
                text("Now: " + (elapsed/1000).toFixed(1) + "s", currentX, height/2 - 80);
            }
            
            // Progress bar
            fill(0, 150, 255, 100);
            noStroke();
            rect(50, height/2 + 80, map(elapsed, 0, maxTime, 0, timelineWidth), 20);
            stroke(0);
            strokeWeight(1);
            noFill();
            rect(50, height/2 + 80, timelineWidth, 20);
        }

        function drawInstructions() {
            fill(100);
            text("Click 'Start Timeline' to begin the sequence", width/2, height/2 - 50);
            text("The main event occurs at 3 seconds", width/2, height/2 - 20);
            text("Watch for events that happen AFTER the main event", width/2, height/2 + 10);
            
            // Preview timeline
            stroke(200);
            strokeWeight(2);
            line(100, height/2 + 60, width-100, height/2 + 60);
            fill(150);
            noStroke();
            circle(200, height/2 + 60, 15);
            text("Main Event", 200, height/2 + 90);
            
            for (let i = 0; i < 3; i++) {
                circle(300 + i * 80, height/2 + 60, 12);
                text("After " + (i+1), 300 + i * 80, height/2 + 90);
            }
        }

        function updateStatus() {
            let elapsed = millis() - timeline.startTime;
            let status = "";
            
            if (elapsed < timeline.mainEventTime) {
                status = "Waiting for main event... (" + ((timeline.mainEventTime - elapsed)/1000).toFixed(1) + "s remaining)";
            } else {
                let triggeredCount = timeline.afterEvents.filter(e => e.triggered).length;
                status = "Main event completed! After events triggered: " + triggeredCount + "/" + timeline.afterEvents.length;
            }
            
            document.getElementById('status').innerHTML = status;
        }

        function startTimeline() {
            timeline.startTime = millis();
            timeline.running = true;
            for (let event of timeline.afterEvents) {
                event.triggered = false;
            }
        }

        function resetTimeline() {
            timeline.running = false;
            timeline.startTime = null;
            for (let event of timeline.afterEvents) {
                event.triggered = false;
            }
            document.getElementById('status').innerHTML = "Timeline: Ready to start";
        }
    </script>
</body>
</html>
